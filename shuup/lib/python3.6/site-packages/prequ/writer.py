import os
from itertools import chain

from click import unstyle

from ._compat import ExitStack
from .file_replacer import FileReplacer
from .logging import log
from .utils import (
    UNSAFE_PACKAGES, comment, dedup, format_requirement, formatted_as,
    key_from_ireq, normalize_req_name)


class OutputWriter(object):
    def __init__(self, src_files, dst_file, dry_run, emit_header, emit_index,
                 emit_trusted_host, annotate, generate_hashes,
                 default_index_url, index_urls, trusted_hosts,
                 find_links, format_control, silent=False):
        self.src_files = src_files
        self.dst_file = dst_file
        self.dry_run = dry_run
        self.emit_header = emit_header
        self.emit_index = emit_index
        self.emit_trusted_host = emit_trusted_host
        self.annotate = annotate
        self.generate_hashes = generate_hashes
        self.default_index_url = default_index_url
        self.index_urls = index_urls
        self.trusted_hosts = trusted_hosts
        self.find_links = find_links
        self.format_control = format_control
        self.silent = silent

    def _sort_key(self, ireq):
        line_format = formatted_as(ireq, self.find_links)
        section_num = {'path': 0}.get(line_format, 9)
        return (section_num, key_from_ireq(ireq))

    def write_header(self):
        if self.emit_header:
            yield comment('# This file is autogenerated by Prequ.  To update, run:')
            yield comment('#')
            yield comment('#   prequ update')
            yield comment('#')

    def write_index_options(self):
        if self.emit_index:
            for index, index_url in enumerate(dedup(self.index_urls)):
                if index_url.rstrip('/') == self.default_index_url:
                    continue
                flag = '--index-url' if index == 0 else '--extra-index-url'
                yield '{} {}'.format(flag, index_url)

    def write_trusted_hosts(self):
        if self.emit_trusted_host:
            for trusted_host in dedup(self.trusted_hosts):
                yield '--trusted-host {}'.format(trusted_host)

    def write_find_links(self):
        yielded = set()
        dst_dir = os.path.dirname(self.dst_file)
        for abs_link in self.find_links:
            rel_link = os.path.relpath(abs_link, start=dst_dir)
            if not rel_link.startswith(os.path.pardir + os.path.sep):
                # Only yield links which are relative to dst_file, since
                # absolute paths shouldn't be stored to requirements.txt
                if rel_link not in yielded:
                    yield '--find-links {}'.format(rel_link)
                    yielded.add(rel_link)

    def write_format_controls(self):
        for nb in dedup(self.format_control.no_binary):
            yield '--no-binary {}'.format(nb)
        for ob in dedup(self.format_control.only_binary):
            yield '--only-binary {}'.format(ob)

    def write_flags(self):
        emitted = False
        for line in chain(self.write_index_options(),
                          self.write_trusted_hosts(),
                          self.write_find_links(),
                          self.write_format_controls()):
            emitted = True
            yield line
        if emitted:
            yield ''

    def _iter_lines(self, results, unsafe_requirements, reverse_dependencies,
                    primary_packages, markers, hashes, allow_unsafe=False):
        for line in self.write_header():
            yield line
        for line in self.write_flags():
            yield line

        unsafe_requirements = {r for r in results if r.name in UNSAFE_PACKAGES} if not unsafe_requirements else unsafe_requirements  # noqa
        packages = {r for r in results if r.name not in UNSAFE_PACKAGES}

        packages = sorted(packages, key=self._sort_key)

        for ireq in packages:
            line = self._format_requirement(
                ireq, reverse_dependencies, primary_packages,
                markers.get(key_from_ireq(ireq)), hashes=hashes)
            yield line

        if unsafe_requirements:
            unsafe_requirements = sorted(unsafe_requirements, key=self._sort_key)
            yield ''
            yield comment('# The following packages are considered to be unsafe in a requirements file:')

            for ireq in unsafe_requirements:
                req = self._format_requirement(ireq,
                                               reverse_dependencies,
                                               primary_packages,
                                               marker=markers.get(key_from_ireq(ireq)),
                                               hashes=hashes)
                if not allow_unsafe:
                    yield comment('# {}'.format(req))
                else:
                    yield req

    def write(self, results, unsafe_requirements, reverse_dependencies,
              primary_packages, markers, hashes, allow_unsafe=False):
        with ExitStack() as stack:
            f = None
            if not self.dry_run:
                f = stack.enter_context(FileReplacer(self.dst_file))

            for line in self._iter_lines(results, unsafe_requirements, reverse_dependencies,
                                         primary_packages, markers, hashes, allow_unsafe=allow_unsafe):
                if not self.silent:
                    log.info(line)
                if f:
                    f.write(unstyle(line).encode('utf-8'))
                    f.write(os.linesep.encode('utf-8'))

    def _format_requirement(self, ireq, reverse_dependencies, primary_packages, marker=None, hashes=None):
        line = format_requirement(
            ireq,
            marker=marker,
            root_dir=os.path.dirname(self.dst_file),
            find_links_dirs=self.find_links)

        ireq_hashes = (hashes if hashes is not None else {}).get(ireq)
        if ireq_hashes:
            for hash_ in sorted(ireq_hashes):
                line += " \\\n    --hash={}".format(hash_)

        if not self.annotate or key_from_ireq(ireq) in primary_packages:
            return line

        # Annotate what packages this package is required by
        required_by = reverse_dependencies.get(key_from_ireq(ireq), [])
        if required_by:
            annotation = ", ".join(
                normalize_req_name(x) for x in sorted(required_by))
            line = "{:24}{}{}".format(
                line,
                " \\\n    " if ireq_hashes else "  ",
                comment("# via " + annotation))
        return line
